<!DOCTYPE html>
<html>
<head>
  <title>WebRTC codelab</title>
  <style>
    video {
      display:none;
    }
    canvas {
      background: transparent;
    }
    #canvas-div button {
      position:absolute;
      top:500px;
    }
  </style>
  <script src="js/util.js"></script>
</head>
<body>
  <video id="camera-input"></video>
  <canvas height="360" width="480"></canvas>
  <br>
  <div>
    <button id="snapshot">Take a Photo</button>
    <button id="motion-blur">Blur</button>
    <button id="stop">Stop</button>

    <br><br>
    <input class="filter" type="checkbox" name="filter" value="grayscale">Grayscale<br>
    <input class="filter" type="checkbox" name="filter" value="invert">Invert<br>
    <input class="filter" type="checkbox" name="filter" value="threshold">Threshold<br>
    <input class="filter" type="checkbox" name="filter" value="brightness">Brightness<br>
    <input class="filter" type="checkbox" name="filter" value="saturate">saturate<br>
    <input class="filter" type="checkbox" name="filter" value="contrast">contrast<br>
    <input class="filter" type="checkbox" name="filter" value="sepia">Sepia<br>
    <input class="filter" type="checkbox" name="filter" value="bayer">Bayer Monochrome<br>
    <input class="filter" type="checkbox" name="filter" value="bayerColor">Bayer 8Color<br>
    <input class="filter" type="checkbox" name="filter" value="lowResColor">4bit RGB 16 Color<br>
    <input class="filter" type="checkbox" name="filter" value="median">Median<br>
    <input class="filter" type="checkbox" name="filter" value="emboss">emboss<br>
    <input class="filter" type="checkbox" name="filter" value="burnX">burn xor<br>
    <input class="filter" type="checkbox" name="filter" value="burnO">burn or<br>
    <input class="filter" type="checkbox" name="filter" value="burnA">burn and<br>

    <button class="convolver">Laplace</button>
    <button class="convolver">Sobel</button>
    <button class="convolver">Sharpen</button>
    <button class="convolver">Blur</button>
    <button class="convolver">Emboss</button>
    <button class="convolver">Edge</button>
    <button id="reset">Reset</button>

    <button id='loop'>Store last second of video</button>
  </div>

  <script>
   navigator.getUserMedia = navigator.getUserMedia ||
                            navigator.webkitGetUserMedia ||
                            navigator.mozGetUserMedia;


    var hdConstraints = {
      video: {
        mandatory: {
          minWidth: 1280,
          minHeight: 720
        }
      }
    };

    var sdConstraints = {
      video: {
        mandatory: {
          minWidth: 480,
          minHeight: 360
        }
      }
    };

    var dataBuffer = -1;

    var contrast_lookup = {};
    var newValue = 0;
    c = (100.0 + 24) / 100.0;

    c *= c;

    for (var i = 0; i < 256; i++) {
      newValue = i;
      newValue = newValue / 255.0;
      newValue -= 0.5;
      newValue *= c;
      newValue += 0.5;
      newValue *= 255;

      if (newValue < 0)
        newValue = 0;
      if (newValue > 255)
        newValue = 255;
      contrast_lookup[i] = newValue | 0;  
    }

    // var gray = [];
    // var iterator;
    // for (iterator = 0; iterator < 256; iterator++) {
    //   gray[r]
      
      
    // }
    
    /* The first function sorts integer elements with the same signs:*/
    function BitwiseSort(array, length) {
      var n = length;
      var A0 = [];
      var A1 = [];
      
      // size of a javascript number less the sign bit.
      // assumes all numbers are positive.
      var tminus = 31;
      /* A0 remembers the elements for which the k-th bit is 0 */
      /* A1 remembers the elements for which the k-th bit is 1 */
      var n0; // size of A0
      var n1; // size of A1
      var k = 20;
      while (++k < 31) {
        /* k - number of the bit The numeration starts from 0. Does not check the sign bit */
        n0=0;
        n1=0;
        for (var i=0; i<n; ++i) {
          /* checks the k-th bit of the i-th element of the array: */
          if (array[i] & (1<<k)) {
            A1[n1] = array[i];
            ++n1;
          } else {
            A0[n0] = array[i];
            ++n0;
          }
        }
        //  We merge the two arrays. As a result we obtain an array
        //   whose elements if the k-th bit is equal to 0 are at the beginning,
        //   and if it is equal to 1 at the end. 
        for (var i=0; i<n0; ++i) {
          array[i] = A0[i];
        }

        for (var i=0; i<n1; ++i) {
          array[n0+i] = A1[i];
        }
      }

      return array[array.length - 1] >> 1;
    } 
      
      
  


    function grayscale(r,g,b) {
      return (0.21 * r + 0.72 * g + 0.07 * b);
    }

    function compareNumbers(a,b) {
      return a - b;
    }

    function onError(error) {
      console.log("getUserMedia encountered the following error: " + error);
    }

    var Filter = {
      convolverActive: false,

      convolve: function(pixels, weights, opacity) {
        // This determines how many rows the kernal has
        var side = Math.round(Math.sqrt(weights.length));
        // offset based on kernal size
        var halfSide = Math.floor(side/2);
        var src = pixels.data;
        // source width
        var sw = pixels.width;
        // source height
        var sh = pixels.height;
        // pad output by the convolution matrix

        var output  = document.createElement("canvas").getContext("2d").createImageData(sw,sh);
        var dst = output.data;
        // go through the destination image pixels
        var alphaFac = opacity ? 1 : 0;
        var y = 0;

        while ((++y) < sh) {
          var x = 0;
          while ((++x) < sw) {
            // alias for further manipulation
            var sy = y;
            var sx = x;

            var dstOff = (y*sw+x)*4;
            // calculate the weighed sum of the source image pixels that
            // fall under the convolution matrix
            var r = 0, g = 0, b = 0, a =0;
            //var cy = 0;

            // cy refers the the kernal row, the first row of the matrix
            for (var cy=0; cy<side; cy++) {
              //var cx = 0;
              //cy refers to each element within the kernal row
              for (var cx=0; cx<side; cx++) {

                var scy = sy + cy - halfSide;
                var scx = sx + cx - halfSide;
                if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                  var srcOff = (scy*sw+scx)*4;

                  var wt = weights[cy*side+cx];

                  r += src[srcOff] * wt;
                  g += src[++srcOff] * wt;
                  b += src[++srcOff] * wt;
                  a += src[++srcOff] * wt;
                }
              }
            }
            dst[dstOff] = r;
            dst[++dstOff] = g;
            dst[++dstOff] = b;
            dst[++dstOff] = 255;
          }
        }
        return output;
      },

      saturate: function(imageData, change) {
        var PR = 0.299;
        var PG = 0.587;
        var PB = 0.114;

        change = change || 2;

        var data = imageData.data;
        var length = data.length;
        var r,g,b;
        var i = 0;

        for(i; i < length; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];

          var p = Math.sqrt( ((r*r) * PR) + ((g*g) * PG) + ((b*b) * PB) );

          data[i] =   p + (r-p) * change;
          data[i+1] = p + (g-p) * change;
          data[i+2] = p + (b-p) * change;
        }

        return data;
      },

      contrast: function(imageData, contrast) {      
        var data = imageData.data;
        var length = data.length;
        var r,g,b;
        var i = 0;
        // contrast = 12;

        // contrast = (contrast + 100.0)/100.0;
        // contrast *= contrast;

        for( i; i < length; i = i + 4) {
          // r = data[i] / 255.0;
          // g = data[i+1] / 255.0;
          // b = data[i+2] / 255.0;
          
          // r =   (((r - 0.5) * contrast) + 0.5) * 255;
          // g = (((g - 0.5) * contrast) + 0.5) * 255;
          // b =  (((b - 0.5) * contrast) + 0.5) * 255;

          data[i] =   contrast_lookup[data[i]]//r < 0 ? 0 : r > 255 ? 255 : r | 0;
          data[i+1] = contrast_lookup[data[i+1]]//g < 0 ? 0 : g > 255 ? 255 : g | 0;
          data[i+2] =  contrast_lookup[data[i+2]]//b < 0 ? 0 : b > 255 ? 255 : b | 0;
        }

        return data;
      },

      grayscale: function(imageData) {
        /* The human eye is most sensitive to green, then red, then blue
         * so each of the colors is weighted differently.
         * The first 1 bit is shifted over three places the the right and
         * excess bits are discarded.  This basically divides by 8 and rounds.
         *
         * Returns a weighted average of the colors
        */
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];

          data[i] = data[i+1] = data[i+2] = (0.21 * r + 0.72 * g + 0.07 * b);//3*r+4*g+b) >>> 3
        }

        return data
      },

      burnX: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r ^ (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g ^ (data[i - 20000] || 255);
          data[i+2] = b ^ (data[i * 2] || 255);
        }

        return data
      },

      burnO: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r | (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g | (data[i - 20000] || 255);
          data[i+2] = b | (data[i * 2] || 255);
        }

        return data
      },

      burnA: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r & (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g & (data[i - 20000] || 255);
          data[i+2] = b & (data[i * 2] || 255);
        }

        return data
      },

      threshold: function(imageData, threshold) {
        /* Make the blacks black and the whites white */

        threshold = threshold || 70

        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];

          // >>> 3 divides the total by 8 and rounds down.
          data[i] = data[i+1] = data[i+2] = ((3*r+4*g+b) >>> 3) >= threshold ? 255 : 0;
        }

        return data;
      },

      invert: function(imageData) {
        var length = imageData.data.length,
            ii = 0,
            data = imageData.data;

        for (ii; ii < length; ii += 4) {
          data[ii] = 255 - data[ii];
          data[ii + 1] = 255 - data[ii + 1];
          data[ii + 2] = 255 - data[ii + 2];
        }

        return data;
      },

      brightness: function(imageData, lum) {
        var length = imageData.data.length,
            ii = 0,
            data = imageData.data;

        lum = lum || 22;

        for (ii; ii < length; ii += 4) {
          data[ii] = data[ii] + lum;
          data[ii + 1] = data[ii + 1] + lum;
          data[ii + 2] = data[ii + 2] + lum;
        }

        return data;
      },

      sepia: function(imageData) {
        var data = imageData.data;
        var length = data.length;
        var ii = 0;

        for (ii; ii < length; ii += 4) {
          var r = data[ii];
          var g = data[ii+1];
          var b = data[ii+2];

          data[ii] = ((r * 0.393) + (g * 0.769) + (b * 0.189)) | 0;
          data[ii+1] = ((r * 0.349) + (g * 0.686) + (b * 0.168)) | 0;
          data[ii+2] = ((r * 0.272) + (g * 0.534) + (b * 0.131)) | 0;
        }
        return data;
      },

      emboss: function(imageData) {
        var w = imageData.width;
        var data = imageData.data;
        var length = data.length;
        var i = 0;

        for (i; i < length; ++i) {
          if ( (i & 3) == 3 ) continue;

          data[i] = 125 + (data[i] << 1) - data[i + 4] - data[i + (w << 2)];
        }

        return imageData;
      },

      // Perform some gameboy era pixelations
      bayer: function(imageData) {
        var w = imageData.width;
        var data = imageData.data;
        var length = data.length;

        var i = 0;
        var matrix = [3,7,4,6,1,9,2,8,5];

        while ((i = i + 4) < length) {
          var  ii = (i >> 2);
          var x = (ii % w);
          var y = ((ii - x) / w);
          // Scale our color value (0-765) in between 1 and 9
          /*
           * General scaling formula
           * initial_range := (min..max)
           * target_range := (a..b)
           * x := some value in the initial range
           *
           * ((b - a) * (x - min) / (max - min)) + 1
          */
          var pixVal = (((8 * (data[i]+data[i+1]+data[i+2])) / 765) | 0) + 1;

          data[i] = data[i + 1] = data[i + 2] = pixVal >= matrix[(y%3)*3+(x%3)] ? 255 : 0;
        }

        return data;
      },

      bayerColor: function(imageData) {
        var w = imageData.width;
        var data = imageData.data;
        var length = data.length;

        var i = 0;
        var bayerColor = {
          0: [0,0,0],
          1: [255,0,0],
          2: [0,255,0],
          3: [0,0,255],
          4: [255,255,0],
          5: [255,0,255],
          6: [0,255,255],
          7: [100,100,100],
          8: [255,255,255],
          9: [255,255,255]
        }

        while ((i = i + 12) < length) {
          var pixVal = (((8 * (data[i]+data[i+1]+data[i+2])) / 765) | 0) + 1;
          var newcolor = bayerColor[pixVal];
          
          data[i] = newcolor[0];
          data[i+1] = newcolor[1];
          data[i+2] = newcolor[2];
        }

        return data;
      },

      lowResColor: function(imageData) {
        var data = imageData.data;
        var length = data.length;

        var i = 0;

        var RGB = [
          [0,0,0],    
          [0,0,170],  
          [0,170,0],
          [0,170,170],
          [170,0,0],
          [170,0,170],
          [170,85,0],
          [85.85,85],
          [85,85,255],
          [85,255,85],
          [85,255,255],
          [255,85,85],
          [255,85,255],
          [255,255,85],
          [255,255,255]
        ];
        
        var len = RGB.length;

        function clamp(r,g,b) {
          var i = 1;
          var color = RGB[0];


          var next;
          var clampIdx = 0;

          if (r == color[0] && g == color[1] && b == color[2]) return color;

          var x = r - color[0];
          var y = g - color[1];
          var z = b - color[2];

          var distance = x*x + y*y + z*z;


          while (i < len) {
            color = RGB[i];

            var x = r - color[0];
            var y = g - color[1];
            var z = b - color[2];

            var next = x*x + y*y + z*z;

            if (next < distance) {
              distance = next;
              clampIdx = i;
            }
            i++;
          }

          return RGB[clampIdx];
        }

        var clamped;
        while ((i = i + 4) < length) {
          clamped = clamp(data[i], data[i+2], data[i+2]);
          
          data[i] = clamped[0];
          data[i+1] = clamped[1];
          data[i+2] = clamped[2];
        }

        return data;
      },


      median: function(srcData, filterSize) {
        var h = srcData.height,
            w = srcData.width,
            dstPixels = pixels = srcData.data,
            neighbors = [],
            filterSize = 7,
            edge = filterSize,
            halfEdge = (edge >> 1) | 0;

        // We need to loop through every pixel of the source image
        for (var x = 0; x < w; ++x) {
          for (var y = 0; y < h; ++y) {
            // Maintain a separate variable to act as an accessor
            // for the neighbors array, reset on each iteration
            var count = 0;
            // Shifting two bits to the left multiples the total product
            // by 4.
            var dstOffset = (y * w + x) << 2;
            neighbors.length = 0;

            // This set of loops defines the maxtrix "window" that we'll
            // move over our pixels to get all neighboring values
            for (var xx = 0; xx < edge; ++xx) {
              for (var yy = 0; yy < edge; ++yy) {
                // get the x and y coords of where our lil'
                // window is right now in the image
                var scx = x + xx - halfEdge;
                var scy = y + yy - halfEdge;

                // Is our window within the bounds of the image?
                if ( scx >= 0 && scx < w && scy >= 0 && scy < h) {

                  var windowPos = (scy * w + scx) << 2;
                  
                  // Stuff the color data into a single int
                  var result = pixels[windowPos] << 24; // roy
                  result |= pixels[++windowPos] << 16; // gee
                  result |= pixels[++windowPos] << 8; // biv
                  
                  neighbors[count] = result;
                  count++;
                }
              }
            }

            //var color = BitwiseSort(neighbors, neighbors.length);
            //var color = neighbors[((neighbors.length - 1)  >> 1) | 0];
            var color = neighbors.sort(compareNumbers)[((neighbors.length - 1)  >> 1) | 0];

            dstPixels[dstOffset] = color >> 24 & 0xff;
            dstPixels[++dstOffset] = color >> 16 & 0xff;
            dstPixels[++dstOffset] = color >> 8 & 0xff;
          }
        }
        return dstPixels;
      }
    };

    // Takes width and height, returns an empty image data array for
    // processing.
    function generateImageData(w, h) {
      return document.createElement("canvas").getContext("2d").getImageData(0, 0, w, h);
    }
    

    // Take a snapshot with your browser
    function PhotoBooth() {
      // Do we have an active booth
      this.active = false;

      // The media stream object
      this.stream = null;

      // The booth itself
      this.canvas = document.querySelector("canvas");

      // An in-memory canvas for convolution effects.
      this.feed = document.createElement("canvas");

      // The video element playing our camera feed.
      this.video = document.getElementById("camera-input");

      // The canvas context
      this.canvasCtx = null;

      // Has the user allowed camera access
      this.allowedAccessToCamera = false;

      // The aspect ratio
      this.aspectRatio = null;

      this.shouldStore = false;

      this.filters = [];

      this.height = this.canvas.height;
      this.width = this.canvas.width;

      this.canvas.width = this.width * 2;
      this.canvas.height = this.height * 2;

      this.canvas.style.width = this.width + 'px';
      this.canvas.style.height = this.height + 'px';


      this.canvas.getContext('2d').scale(2, 2);

      this.requestAccess();
      this.bindEvents();
    }

    PhotoBooth.prototype = {
      bindEvents: function() {
        document.getElementById("snapshot").addEventListener("click", this.takePhoto.bind(this));
        document.getElementById("motion-blur").addEventListener("click", this.blur.bind(this));
        document.getElementById("stop").addEventListener("click", this.toggleVideo.bind(this));
        var nodes = document.querySelectorAll(".filter")

        for  (var i = 0; i < nodes.length; i++) {
          nodes[i].addEventListener("click", this.addFilter.bind(this));
        }

        var convolvers = document.querySelectorAll(".convolver");

        for  (var i = 0; i < convolvers.length; i++) {
          convolvers[i].addEventListener("click", this.convolve.bind(this));
        }

        document.getElementById("reset").addEventListener("click", this.reset.bind(this));
        document.getElementById("loop").addEventListener('click', this.store.bind(this))
      },

      store: function() {
        if (this.shouldStore) {
          dataBuffer.length = 0;
        }

        this.shouldStore = !this.shouldStore;
        
      },

      requestAccess: function() {
        navigator.getUserMedia({
          video: true
        }, this._onAccessGranted.bind(this),
           this._onAccessDenied.bind(this)
        );
      },

      _onAccessDenied: function() {
        console.log('User denied access to the webcam.');
      },

      _onAccessGranted: function(localMediaStream) {
        // State variables for the photo booth
        this.stream = localMediaStream;
        this.active = true;
        this.allowedAccessToCamera = true;


        // Local variables for drawing
        var rfid = null;
        this.video.src = window.URL.createObjectURL(this.stream);

        this.video.addEventListener("loadeddata", this._onVideoDataReady.bind(this));
      },

      draw: function(time) {
        var i = 0;

        if (!this._isActive()) {
          return window.cancelAnimationFrame(this.rfid);
        }

        this.canvasCtx.drawImage(this.video, 0, 0);
        var output = imageData = this.canvasCtx.getImageData(0, 0, this.width*2, this.height*2);
        

        if (this.convolver) {
          imageData = output = Filter.convolve(imageData, this.convolver.matrix);
        }

        if (this.filters.length != 0) {
          while(i < this.filters.length) {
            output.data = Filter[this.filters[i]](output);
            i++;
          }

          this.canvasCtx.putImageData(output, 0, 0);
        } else {
          this.canvasCtx.putImageData(imageData, 0, 0);
        }
        var self = this;
        
        
          if (dataBuffer === -1) {
            dataBuffer = [];
          } else if (dataBuffer.length === 0) {
            dataBuffer = output;  
          }

        this.rfid =  window.requestAnimationFrame(self.draw.bind(self));
        
      },

      _onVideoDataReady: function(evt) {
        this.video.play();

        this.canvasCtx = this.canvas.getContext("2d");

        var output = imageData = null;

        this.rfid = window.requestAnimationFrame(this.draw.bind(this));
      },

      addFilter: function(evt) {
        if (!this.allowedAccessToCamera && !this._isActive) return false;

        var selectedFilter = evt.currentTarget.value;

        if (this.filters.indexOf(selectedFilter) !== -1) {
          this.filters.splice(this.filters.indexOf(selectedFilter), 1);

          return;
        }

        this.filters.push(selectedFilter);
      },

      convolve: function(evt) {
        var convolver = evt.currentTarget.innerHTML.toLowerCase();

        if (this.convolver && this.convolver.type === convolver) {
          return this.convolver = null;
        }

        switch (convolver) {
          case "laplace":
            this.convolver = {
              type: convolver,
              matrix: [1,1,1,1,-8,1,1,1,1]
            };
            break;
          case "sharpen":
            this.convolver = {
              type: convolver,
              matrix: [0,-1,0,-1,5,-1,0,-1,0]
            };
            break;
          case "blur":
            var b = 1/9;
            this.convolver = {
              type: convolver,
              matrix: [b,b,b,b,b,b,b,b,b]
            };
            break;
          case "edge":
            this.convolver = {
              type: convolver,
              matrix: [-6,-4,0,-10,10,1,0,4,6]
            }
            break;
          case "emboss":
            this.convolver = {
              type: convolver,
              matrix: [-2,-1,0,-1,1,1,0,1,2]
            }
            break;
          case 'sobel':
            this.convolver = {
              type: convolver,
              matrix: [-1,0,1,-2,0,2,-1,0,1]
            }
            break;
        }
      },

      _isActive: function() {
        return this.active && this.stream;
      },

      blur: function() {
        if (!this._isActive()) return false;


        var ctx = this.canvas.getContext("2d"),
            currentAlpha = ctx.globalAlpha;

        ctx.globalAlpha = currentAlpha > 0.1 && currentAlpha < 0.2 ? 1.0 : 0.1;
      },

      toggleVideo: function() {
        if (this._isActive()) {
          this.video.pause();
          this.active = false;
        } else {
          this.video.play();
          this.active = true;
          this.draw();
        }
      },

      takePhoto: function(evt) {
        //if (!this._isActive()) return false;

        var anchor, click;

        anchor = document.createElement("a");
        anchor.href = this.canvas.toDataURL("image/png");
        //window.location = this.canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
        //return;
        anchor.download = "image"+ +new Date() + ".png";

//anchor.innerHTML = 'p';
  //  document.body.appendChild(anchor);
  //  return;
        click = document.createEvent("Event");
        click.initEvent("click", true, true);

        anchor.dispatchEvent(click);
      },

      reset: function() {
        this.filters.length = 0;
      }
    };

    if (chrome && /Chrome\/(2{1}9{1}|3{1}[0-9])/.test(navigator.appVersion)) {
      new PhotoBooth();
    } else {
      alert("This page only supports Google Chrome, version 29 or higher.");
    }
  </script>
</body>
</html>
