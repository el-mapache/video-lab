<!DOCTYPE html>
<html>
<head>
  <title>WebRTC codelab</title>
  <style>
    video {
      display:none;
    }
    canvas {
      background: transparent;
    }
  </style>

  <script type="text/template" id="variable-filter">
    <form oninput="level.value = {{=it.name}}.valueAsNumber;">
      <input class="filter" type="checkbox" name="filter"/>{{=it.name}}
      <input type="range" min="{{=it.min}}" max="{{=it.max}}" id="{{=it.name}}-filter" name="{{=it.name}}" value="{{=it.currentValue}}" step="{{=it.step}}"/>
      <output style="margin-left: 20px; padding:14px;" for="{{=it.name}}-filter" name="level">{{=it.currentValue}}</output>
    </form>
  </script>

  <script type="text/template" id="fixed-filter">
    <input class="filter" type="checkbox" name="filter" value="{{=it.name}}">{{=it.name}}<br>
  </script>
  
  <script src='js/dot.js'></script>
  <script src="js/util.js"></script>
  <script src="js/services.js"></script>
  <script src="js/framework.js"></script>
  <script src="js/collections/filter-collection.js"></script>
  <script src="js/models/grayscale-filter.js"></script>
  <script src="js/models/contrast-filter.js"></script>
  <script src="js/models/brightness-filter.js"></script>
  <script src="js/models/saturation-filter.js"></script>
  <script src="js/models/inversion-filter.js"></script>
  <script src="js/models/sepia-filter.js"></script>
  <script src="js/models/emboss-filter.js"></script>
  <script src="js/views/grayscale-view.js"></script>
  <script src="js/views/contrast-view.js"></script>
  <script src="js/views/brightness-view.js"></script>
  <script src="js/views/saturation-view.js"></script>
  <script src="js/views/inversion-view.js"></script>
  <script src="js/views/sepia-view.js"></script>
  <script src="js/views/emboss-view.js"></script>
</head>
<body>
  <video id="camera-input"></video>
  <canvas height="360" width="480"></canvas>
  <br>
  <div style='float:right; margin-right:200px;'>
    <div id='cc'></div>
  </div>
  <div>
    <button id="snapshot">Take a Photo</button>
<!--     <form name='canvas-blur' oninput="level.value = canvasBlur.valueAsNumber;">
      <label for="canvasBlur">Blur</label>
      <input type="range" min="0.0" max="1.0" step="0.1" id="canvasBlur" name="canvasBlur" value="1.0"/>
      <output for="canvasBlur" name="level">1.0</output>
    </form> -->

    <button id="stop">Stop</button>
    <div class='filters'>
    <br><br>
    <div id='grayscale'></div>
    <div id='contrast'></div>
    <div id='brightness'></div>
    <div id='saturation'></div>
    <div id='invert'></div>
    <div id='sepia'></div>
    <div id='emboss'></div>
    
    
<!--     <input class="filter" type="checkbox" name="filter" value="threshold">Threshold<br>
    
    <input class="filter" type="checkbox" name="filter" value="saturate">saturate<br>
    <input class="filter" type="checkbox" name="filter" value="contrast">contrast<br>
    <input class="filter" type="checkbox" name="filter" value="sepia">Sepia<br>
    <input class="filter" type="checkbox" name="filter" value="bayer">Bayer Monochrome<br>
    <input class="filter" type="checkbox" name="filter" value="bayerColor">Bayer 8Color<br>
    <input class="filter" type="checkbox" name="filter" value="lowResColor">4bit RGB 16 Color<br>
    <input class="filter" type="checkbox" name="filter" value="median">Median<br>
    <input class="filter" type="checkbox" name="filter" value="emboss">emboss<br>
    <input class="filter" type="checkbox" name="filter" value="burnX">burn xor<br>
    <input class="filter" type="checkbox" name="filter" value="burnO">burn or<br>
    <input class="filter" type="checkbox" name="filter" value="burnA">burn and<br> -->

    <button class="convolver" value='laplace'>Laplace</button>
    <button class="convolver" value='sobel'>Sobel</button>
    <button class="convolver" value='sharpen'>Sharpen</button>
    <button class="convolver" value="blur">Blur</button>
    <button class="convolver" value="emboss">Emboss</button>
    <button class="convolver" value="edge">Edge</button>
</div>
    <button id="reset">Reset</button>

    <button id='loop'>Store last second of video</button>
  </div>

  <script>
    var collection = new FilterCollection();
    
    var gsf = new GrayscaleFilter();
    var bf = new BrightnessFilter();
    var cf = new ContrastFilter();
    var sf = new SaturationFilter();
    var ivf = new InversionFilter();
    var spf = new SepiaFilter();
    var ef = new EmbossFilter();

    collection.add([gsf, cf, bf, sf, ivf, spf, ef]);


    gsv = new GrayscaleView({model: gsf}).render();
    cfv = new ContrastView({model: cf}).render();
    bfv = new BrightnessView({model: bf}).render();
    sfv = new SaturationView({model: sf}).render();
    ivfv = new InversionView({model: ivf}).render();
    spfv = new SepiaView({model: spf}).render();
    new EmbossView({model: ef}).render();

    var hdConstraints = {
      video: {
        mandatory: {
          minWidth: 1280,
          minHeight: 720
        }
      }
    };

    var sdConstraints = {
      video: {
        mandatory: {
          minWidth: 480,
          minHeight: 360
        }
      }
    };

    var dataBuffer = -1;

    function grayscale(r,g,b) {
      //3*r+4*g+b) >>> 3
      return (0.21 * r + 0.72 * g + 0.07 * b);
    }

    function compareNumbers(a,b) {
      return a - b;
    }

    var Filter = {
      convolverActive: false,

      convolve: function(pixels, weights, opacity) {
        // This determines how many rows the kernal has
        var side = Math.round(Math.sqrt(weights.length));
        // offset based on kernal size
        var halfSide = Math.floor(side/2);
        var src = pixels.data;
        // source width
        var sw = pixels.width;
        // source height
        var sh = pixels.height;
        // pad output by the convolution matrix

        var output  = document.createElement("canvas").getContext("2d").createImageData(sw,sh);
        var dst = output.data;
        // go through the destination image pixels
        var alphaFac = opacity ? 1 : 0;
        var y = 0;

        while ((++y) < sh) {
          var x = 0;
          while ((++x) < sw) {
            // alias for further manipulation
            var sy = y;
            var sx = x;

            var dstOff = (y*sw+x)*4;
            // calculate the weighed sum of the source image pixels that
            // fall under the convolution matrix
            var r = 0, g = 0, b = 0, a =0;
            //var cy = 0;

            // cy refers the the kernal row, the first row of the matrix
            for (var cy=0; cy<side; cy++) {
              //var cx = 0;
              //cy refers to each element within the kernal row
              for (var cx=0; cx<side; cx++) {

                var scy = sy + cy - halfSide;
                var scx = sx + cx - halfSide;
                if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                  var srcOff = (scy*sw+scx)*4;

                  var wt = weights[cy*side+cx];

                  r += src[srcOff] * wt;
                  g += src[++srcOff] * wt;
                  b += src[++srcOff] * wt;
                  a += src[++srcOff] * wt;
                }
              }
            }
            dst[dstOff] = r;
            dst[++dstOff] = g;
            dst[++dstOff] = b;
            dst[++dstOff] = 255;
          }
        }
        return output;
      },


      burnX: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r ^ (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g ^ (data[i - 20000] || 255);
          data[i+2] = b ^ (data[i * 2] || 255);
        }

        return data
      },

      burnO: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r | (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g | (data[i - 20000] || 255);
          data[i+2] = b | (data[i * 2] || 255);
        }

        return data
      },

      burnA: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r & (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g & (data[i - 20000] || 255);
          data[i+2] = b & (data[i * 2] || 255);
        }

        return data
      },

      threshold: function(imageData, threshold) {
        /* Make the blacks black and the whites white */

        threshold = threshold || 70

        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];
          // Invert looks marignally better with this grayscale formula
          data[i] = data[i+1] = data[i+2] = ((3*r+4*g+b) >>> 3) >= threshold ? 255 : 0;
        }

        return data;
      },

      // Perform some gameboy era pixelations
      bayer: function(imageData) {
        var w = imageData.width;
        var data = imageData.data;
        var length = data.length;

        var i = 0;
        var matrix = [3,7,4,6,1,9,2,8,5];

        while ((i = i + 4) < length) {
          var  ii = (i >> 2);
          var x = (ii % w);
          var y = ((ii - x) / w);
          // Scale our color value (0-765) in between 1 and 9
          /*
           * General scaling formula
           * initial_range := (min..max)
           * target_range := (a..b)
           * x := some value in the initial range
           *
           * ((b - a) * (x - min) / (max - min)) + 1
          */
          var pixVal = (((8 * (data[i]+data[i+1]+data[i+2])) / 765) | 0) + 1;

          data[i] = data[i + 1] = data[i + 2] = pixVal >= matrix[(y%3)*3+(x%3)] ? 255 : 0;
        }

        return data;
      },

      bayerColor: function(imageData) {
        var w = imageData.width;
        var data = imageData.data;
        var length = data.length;

        var i = 0;
        var bayerColor = {
          0: [0,0,0],
          1: [255,0,0],
          2: [0,255,0],
          3: [0,0,255],
          4: [255,255,0],
          5: [255,0,255],
          6: [0,255,255],
          7: [100,100,100],
          8: [255,255,255],
          9: [255,255,255]
        }

        while ((i = i + 12) < length) {
          var pixVal = (((8 * (data[i]+data[i+1]+data[i+2])) / 765) | 0) + 1;
          var newcolor = bayerColor[pixVal];
          
          data[i] = newcolor[0];
          data[i+1] = newcolor[1];
          data[i+2] = newcolor[2];
        }

        return data;
      },

      lowResColor: function(imageData) {
        var data = imageData.data;
        var length = data.length;

        var i = 0;

        var RGB = [
          [0,0,0],    
          [0,0,170],  
          [0,170,0],
          [0,170,170],
          [170,0,0],
          [170,0,170],
          [170,85,0],
          [85.85,85],
          [85,85,255],
          [85,255,85],
          [85,255,255],
          [255,85,85],
          [255,85,255],
          [255,255,85],
          [255,255,255]
        ];
        
        var len = RGB.length;

        function clamp(r,g,b) {
          var i = 1;
          var color = RGB[0];


          var next;
          var clampIdx = 0;

          if (r == color[0] && g == color[1] && b == color[2]) return color;

          var x = r - color[0];
          var y = g - color[1];
          var z = b - color[2];

          var distance = x*x + y*y + z*z;


          while (i < len) {
            color = RGB[i];

            var x = r - color[0];
            var y = g - color[1];
            var z = b - color[2];

            var next = x*x + y*y + z*z;

            if (next < distance) {
              distance = next;
              clampIdx = i;
            }
            i++;
          }

          return RGB[clampIdx];
        }

        var clamped;
        while ((i = i + 4) < length) {
          clamped = clamp(data[i], data[i+2], data[i+2]);
          
          data[i] = clamped[0];
          data[i+1] = clamped[1];
          data[i+2] = clamped[2];
        }

        return data;
      },


      median: function(srcData, filterSize) {
        var h = srcData.height,
            w = srcData.width,
            dstPixels = pixels = srcData.data,
            neighbors = [],
            filterSize = 7,
            edge = filterSize,
            halfEdge = (edge >> 1) | 0;

        // We need to loop through every pixel of the source image
        for (var x = 0; x < w; ++x) {
          for (var y = 0; y < h; ++y) {
            // Maintain a separate variable to act as an accessor
            // for the neighbors array, reset on each iteration
            var count = 0;
            // Shifting two bits to the left multiples the total product
            // by 4.
            var dstOffset = (y * w + x) << 2;
            neighbors.length = 0;

            // This set of loops defines the maxtrix "window" that we'll
            // move over our pixels to get all neighboring values
            for (var xx = 0; xx < edge; ++xx) {
              for (var yy = 0; yy < edge; ++yy) {
                // get the x and y coords of where our lil'
                // window is right now in the image
                var scx = x + xx - halfEdge;
                var scy = y + yy - halfEdge;

                // Is our window within the bounds of the image?
                if ( scx >= 0 && scx < w && scy >= 0 && scy < h) {

                  var windowPos = (scy * w + scx) << 2;
                  
                  // Stuff the color data into a single int
                  var result = pixels[windowPos] << 24; // roy
                  result |= pixels[++windowPos] << 16; // gee
                  result |= pixels[++windowPos] << 8; // biv
                  
                  neighbors[count] = result;
                  count++;
                }
              }
            }

            var color = neighbors.sort(compareNumbers)[((neighbors.length - 1)  >> 1) | 0];

            dstPixels[dstOffset] = color >> 24 & 0xff;
            dstPixels[++dstOffset] = color >> 16 & 0xff;
            dstPixels[++dstOffset] = color >> 8 & 0xff;
          }
        }
        return dstPixels;
      }
    };


    function CanvasView(el, stream) {
      // Whether or not the view screen is receiving data.
      this.active = false;
      this.canvas = el;
      this.canvasContext = this.canvas.getContext('2d');
      this.stream = stream;
      this.backingVideo = document.createElement('video');


      this.height = this.canvas.height;
      this.width = this.canvas.width;

      this.canvas.width = this.width * 2;
      this.canvas.height = this.height * 2;

      this.canvas.style.width = this.width + 'px';
      this.canvas.style.height = this.height + 'px';

      this.initialize();
    }
    
    CanvasView.prototype.initialize = function() {
      document.getElementById("snapshot").addEventListener("click", this.takePhoto.bind(this));
      this.backingVideo.addEventListener('loadeddata', function() {
        
        this.backingVideo.play();
        this.trigger('ON_VIDEO_LOAD');

      }.bind(this));

      this.backingVideo.src = window.URL.createObjectURL(this.stream);
      this.active = true;
      
      VL.Events.prototype.attachTo(this);
      
      return this;
    };

    CanvasView.prototype.getPixels = function() {
      if (!this.isActive()) {
        return null;
      }

      this.canvasContext.drawImage(this.backingVideo, 0, 0);
      //return this.canvasContext.getImageData(0, 0, this.width, this.height);
      return this.canvasContext.getImageData(0, 0, this.width*2, this.height*2);
    };

    CanvasView.prototype.draw = function(imageData) {
      if (!this.isActive()) {
        return false;
      }

      this.canvasContext.putImageData(imageData, 0, 0);
      
      return true;
    };

    CanvasView.prototype.isActive = function() {
      return this.active;
    };

    CanvasView.prototype.takePhoto = function(evt) {
      var anchor, click;

      anchor = document.createElement("a");
      anchor.href = this.canvas.toDataURL("image/png");
      
      
      anchor.download = "image"+ +new Date() + ".png";

      click = document.createEvent("Event");
      click.initEvent("click", true, true);

      anchor.dispatchEvent(click);
    };

    CanvasView.prototype.constructor = CanvasView;






    function FilterView(el) {
      this.el = el;

      this.activeFilters = collection;
      this.filters = [];

     
      var self = this;
      this.activeFilters.on('model.change.active', function(evt, newVal,oldVal,model) {
        if (newVal) {
          self.addFilter(model);
        } else {
          //
        }
      });
     


      var convolvers = el.querySelectorAll(".convolver");

      for  (var i = 0; i < convolvers.length; i++) {
        convolvers[i].addEventListener("click", this.addFilter.bind(this));
      }
    }


    FilterView.prototype.addFilter = function(filter) {
      this.filters.push(filter);
      
      return this.filters;
    };


    FilterView.prototype.process = function(imageData) {
      function filterPixelData(filter) {
        // if (filter.get('type') === 'convolver') {
        //   imageData = Filter.convolve(imageData, filter.matrix);
        // } else if (filter.get('type') === 'filter') {
          imageData.data = filter.filter(imageData);
       // }
      }

      for (var i = 0; i < this.filters.length; i++) {
        filterPixelData(this.filters[i]);
      }

      return imageData;
    };

    FilterView.prototype._buildConvolver = function(evt) {
      var convolver = evt.currentTarget.value;


      var filter;

      // Todo make these models.
      switch (convolver) {
        case "laplace":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [1,1,1,1,-8,1,1,1,1]
          };
          break;
        case "sharpen":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [0,-1,0,-1,5,-1,0,-1,0]
          };
          break;
        case "blur":
          var b = 1/9;
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [b,b,b,b,b,b,b,b,b]
          };
          break;
        case "edge":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [-6,-4,0,-10,10,1,0,4,6]
          }
          break;
        case "emboss":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [-2,-1,0,-1,1,1,0,1,2]
          }
          break;
        case 'sobel':
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [-1,0,1,-2,0,2,-1,0,1]
          }
          break;
      }

      return filter;
    };

    FilterView.prototype.constructor = FilterView;





    function AppController() {
      // sub view representing the canvas element
      this.canvasView = null;
      // subview representing the filter nodes
      this.filtersView = new FilterView(document.querySelector('.filters'));

      this.allowedAccessToCamera = false;

      // Pointer to the id of the current animation frame
      this.rfid = null;

      this.initialize();
    };


    AppController.prototype.initialize = function() {
      Services.UserMedia.getStream(this.onAfterStreamRequest.bind(this));
    };

    AppController.prototype.onAfterStreamRequest = function(stream) {
      if (!stream) {
        return console.log('User denied access to their webcam.');
      }

      this.allowedAccessToCamera = true;  
      
      this.canvasView = new CanvasView(document.querySelector('canvas'), stream);
      this.canvasView.on('ON_VIDEO_LOAD', this.startAnimationLoop.bind(this));
    };

    AppController.prototype.transform = function(imageData) {
      return this.filtersView.process(imageData);
    };

    AppController.prototype.startAnimationLoop = function() {
      var self = this;

      // TODO make this a two part process, query the canvas for data,
      //transform it, and send it back to be painted.

      function animationCallback() {
        var transformedData = self.transform(self.canvasView.getPixels()); 
        var shouldKeepDrawing = self.canvasView.draw(transformedData);

        if (!shouldKeepDrawing) {
          window.cancelAnimationFrame(self.rfid);
          self.rfid = null;
          return;
        }

        self.rfid = window.requestAnimationFrame(animationCallback);
      }

      this.rfid = window.requestAnimationFrame(animationCallback);
    };


    // Take a snapshot with your browser
    function PhotoBooth() {
      // Do we have an active booth
      this.active = false;

      // The media stream object
      this.stream = null;

      // The booth itself
      this.canvas = document.querySelector("canvas");

      // The video element playing our camera feed.
      this.video = document.getElementById("camera-input");

      // The canvas context
      this.canvasCtx = null;

      // Has the user allowed camera access
      this.allowedAccessToCamera = false;

      // The aspect ratio
      this.aspectRatio = null;

      this.shouldStore = false;

      this.filters = [];

      this.height = this.canvas.height;
      this.width = this.canvas.width;

      this.canvas.width = this.width * 2;
      this.canvas.height = this.height * 2;

      this.canvas.style.width = this.width + 'px';
      this.canvas.style.height = this.height + 'px';


      this.canvas.getContext('2d').scale(2, 2);

      this.requestAccess();
      this.bindEvents();
    }

    PhotoBooth.prototype = {
      bindEvents: function() {
        document.getElementById("snapshot").addEventListener("click", this.takePhoto.bind(this));
        document.getElementById("canvasBlur").addEventListener("input", this.blur.bind(this));
        document.getElementById("stop").addEventListener("click", this.toggleVideo.bind(this));
        var nodes = document.querySelectorAll(".filter")

        for  (var i = 0; i < nodes.length; i++) {
          nodes[i].addEventListener("click", this.addFilter.bind(this));
        }

        var convolvers = document.querySelectorAll(".convolver");

        for  (var i = 0; i < convolvers.length; i++) {
          convolvers[i].addEventListener("click", this.convolve.bind(this));
        }

        document.getElementById("reset").addEventListener("click", this.reset.bind(this));
        document.getElementById("loop").addEventListener('click', this.store.bind(this))
      },

      store: function() {
        if (this.shouldStore) {
          dataBuffer.length = 0;
        }

        this.shouldStore = !this.shouldStore;
      },

      requestAccess: function() {
        Services.UserMedia.getStream(function(stream) {
          if (!stream) {
            return console.log('No webcam acccess');
          }
          
          new ViewScreen(document.querySelector('canvas'), stream);
          this.stream = stream;
          this.active = true;
          this.allowedAccessToCamera = true;

          this.video.src = window.URL.createObjectURL(this.stream);

          this.video.addEventListener('loadeddata', this._onVideoDataReady.bind(this));
        }.bind(this));
      },

      draw: function(time) {
        var i = 0;

        if (!this._isActive()) {
          return window.cancelAnimationFrame(this.rfid);
        }

        this.canvasCtx.drawImage(this.video, 0, 0);
        var output = imageData = this.canvasCtx.getImageData(0, 0, this.width*2, this.height*2);
        

        if (this.convolver) {
          imageData = output = Filter.convolve(imageData, this.convolver.matrix);
        }

        if (this.filters.length != 0) {
          while(i < this.filters.length) {
            output.data = Filter[this.filters[i]](output);
            i++;
          }

          this.canvasCtx.putImageData(output, 0, 0);
        } else {
          this.canvasCtx.putImageData(imageData, 0, 0);
        }
        var self = this;
        
        
          if (dataBuffer === -1) {
            dataBuffer = [];
          } else if (dataBuffer.length === 0) {
            dataBuffer = output;  
          }

        this.rfid =  window.requestAnimationFrame(self.draw.bind(self));
        
      },

      _onVideoDataReady: function(evt) {
        this.video.play();

        this.canvasCtx = this.canvas.getContext("2d");

        var output = imageData = null;

        this.rfid = window.requestAnimationFrame(this.draw.bind(this));
      },

      addFilter: function(evt) {
        if (!this.allowedAccessToCamera && !this._isActive) return false;

        var selectedFilter = evt.currentTarget.value;

        if (this.filters.indexOf(selectedFilter) !== -1) {
          this.filters.splice(this.filters.indexOf(selectedFilter), 1);

          return;
        }

        this.filters.push(selectedFilter);
      },

      convolve: function(evt) {
        var convolver = evt.currentTarget.innerHTML.toLowerCase();

        if (this.convolver && this.convolver.type === convolver) {
          return this.convolver = null;
        }

        switch (convolver) {
          case "laplace":
            this.convolver = {
              type: convolver,
              matrix: [1,1,1,1,-8,1,1,1,1]
            };
            break;
          case "sharpen":
            this.convolver = {
              type: convolver,
              matrix: [0,-1,0,-1,5,-1,0,-1,0]
            };
            break;
          case "blur":
            var b = 1/9;
            this.convolver = {
              type: convolver,
              matrix: [b,b,b,b,b,b,b,b,b]
            };
            break;
          case "edge":
            this.convolver = {
              type: convolver,
              matrix: [-6,-4,0,-10,10,1,0,4,6]
            }
            break;
          case "emboss":
            this.convolver = {
              type: convolver,
              matrix: [-2,-1,0,-1,1,1,0,1,2]
            }
            break;
          case 'sobel':
            this.convolver = {
              type: convolver,
              matrix: [-1,0,1,-2,0,2,-1,0,1]
            }
            break;
        }
      },

      _isActive: function() {
        return this.active && this.stream;
      },

      blur: function(event) {
        if (!this._isActive()) return false;


        var ctx = this.canvas.getContext("2d"),
            currentAlpha = ctx.globalAlpha;

        ctx.globalAlpha = +event.target.value;
      },

      toggleVideo: function() {
        if (this._isActive()) {
          this.video.pause();
          this.active = false;
        } else {
          this.video.play();
          this.active = true;
          this.draw();
        }
      },

      takePhoto: function(evt) {
        //if (!this._isActive()) return false;

        var anchor, click;

        anchor = document.createElement("a");
        anchor.href = this.canvas.toDataURL("image/png");
        //window.location = this.canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
        //return;
        anchor.download = "image"+ +new Date() + ".png";

//anchor.innerHTML = 'p';
  //  document.body.appendChild(anchor);
  //  return;
        click = document.createEvent("Event");
        click.initEvent("click", true, true);

        anchor.dispatchEvent(click);
      },

      reset: function() {
        this.filters.length = 0;
      }
    };

    if (Services.Browser.isChrome()) {
      //new PhotoBooth();
      new AppController();
    } else {
      alert("This page only supports Google Chrome, version 29 or higher.");
    }
  </script>
</body>
</html>
