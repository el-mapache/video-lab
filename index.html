<!DOCTYPE html>
<html>
<head>
  <title>WebRTC codelab</title>
  <style>
    video {
      display:none;
    }
    canvas {
      background: transparent;
    }
  </style>

  <script type="text/template" id="variable-filter">
    <form oninput="level.value = {{=it.name}}.valueAsNumber;">
      <input class="filter" type="checkbox" name="filter"/>{{=it.name}}
      <input type="range" min="{{=it.min}}" max="{{=it.max}}" id="{{=it.name}}-filter" name="{{=it.name}}" value="{{=it.currentValue}}" step="{{=it.step}}" class="variable-filter"/>
      <output style="margin-left: 20px; padding:14px;" for="{{=it.name}}-filter" name="level">{{=it.currentValue}}</output>
    </form>
  </script>

  <script type="text/template" id="fixed-filter">
    <input class="filter" type="checkbox" name="filter" value="{{=it.name}}">{{=it.name}}<br>
  </script>

  <script type="text/template" id="convolver">
    <button class="convolver" value='{{=it.name}}'>{{=it.name}}</button></br>
  </script>
  
  <script src='js/dot.js'></script>
  <script src="js/util.js"></script>
  <script src="js/services.js"></script>
  <script src="js/framework.js"></script>
  <script src="js/collections/filter-collection.js"></script>
  <script src="js/models/convolver.js"></script>
  <script src="js/models/grayscale-filter.js"></script>
  <script src="js/models/contrast-filter.js"></script>
  <script src="js/models/brightness-filter.js"></script>
  <script src="js/models/saturation-filter.js"></script>
  <script src="js/models/inversion-filter.js"></script>
  <script src="js/models/sepia-filter.js"></script>
  <script src="js/models/emboss-filter.js"></script>
  <script src="js/models/threshold-filter.js"></script>
  <script src="js/models/bayer-filter.js"></script>
  <script src="js/models/low-res.js"></script>
  <script src="js/models/xor-filter.js"></script>
  <script src="js/models/median-filter.js"></script>
  <script src="js/models/sobel-filter.js"></script>
  <script src="js/views/filter-view.js"></script>
  <script src="js/views/variable-filter.js"></script>
  <script src="js/views/convolution-view.js"></script>
</head>
<body>
  <video id="camera-input"></video>
  <canvas height="360" width="480"></canvas>
  <br>
  <div style='float:right; margin-right:200px;'>
    <div id='cc'></div>
  </div>
  <div>
    <button id="snapshot">Take a Photo</button>
    <form name='canvas-blur' oninput="level.value = canvasBlur.valueAsNumber;">
      <label for="canvasBlur">Blur</label>
      <input type="range" min="0.0" max="1.0" step="0.1" id="canvasBlur" name="canvasBlur" value="1.0"/>
      <output for="canvasBlur" name="level">1.0</output>
    </form>

    <button id="stop">Stop</button>

    <div class='filters'>
      <br><br>

      <h4>Fixed Filters</h4>
      <div id='grayscale'></div>
      <div id='invert'></div>
      <div id='sepia'></div>
      <div id='emboss'></div>
      <div id='low-res'></div>
      <div id='bayer'></div>
      <div id='xor'></div>

      
      <h4>Variable Filters</h4>

      <div id='contrast'></div>
      <div id='brightness'></div>
      <div id='saturation'></div>
      <div id='threshold'></div>
      <div id='median'></div>

      
      <h4>Convolvers</h4>

      <div id='sobel'></div>
    
    
<!--
    <input class="filter" type="checkbox" name="filter" value="bayerColor">Bayer 8Color<br>
    <input class="filter" type="checkbox" name="filter" value="burnO">burn or<br>
    <input class="filter" type="checkbox" name="filter" value="burnA">burn and<br> -->
      <button class="convolver" value='laplace'>Laplace</button>
      
      <button class="convolver" value='sharpen'>Sharpen</button>
      <button class="convolver" value="blur">Blur</button>
      <button class="convolver" value="emboss">Emboss</button>
      <button class="convolver" value="edge">Edge</button>
    </div>
    <button id="reset">Reset</button>

    <button id='loop'>Store last second of video</button>
  </div>

  <script>
    var collection = new FilterCollection();
    
    var gsf = new GrayscaleFilter();
    var bf = new BrightnessFilter();
    var cf = new ContrastFilter();
    var sf = new SaturationFilter();
    var ivf = new InversionFilter();
    var spf = new SepiaFilter();
    var ef = new EmbossFilter();
    var tf = new ThresholdFilter();
    var byf = new BayerFilter();
    var lrf = new LowResFilter();
    var xof = new XORFilter();
    var mdf = new MedianFilter();
    var sbf = new SobelFilter();


   collection.add([gsf, cf, bf, sf, ivf, spf, ef, tf, byf, lrf, xof, mdf, sbf]);

    // Fixed Filters
    new FixedFilterView({el: '#grayscale', model: gsf}).render();
    new FixedFilterView({el: '#sepia', model: spf}).render();
    new FixedFilterView({el: '#invert', model: ivf}).render();
    new FixedFilterView({el: '#emboss', model: ef}).render();
    new FixedFilterView({el: '#low-res', model: lrf}).render();
    new FixedFilterView({el: '#bayer', model: byf}).render();
    new FixedFilterView({el: '#xor', model: xof}).render(); 

    new VariableFilterView({el: '#saturation', model: sf}).render();
    new VariableFilterView({el: '#contrast', model: cf}).render();
    new VariableFilterView({el: '#brightness', model: bf}).render();
    new VariableFilterView({el: '#threshold', model: tf}).render();
    new VariableFilterView({el: '#median', model: mdf}).render();

    new ConvolutionFilterView({el: '#sobel', model: sbf}).render();
   

    var hdConstraints = {
      video: {
        mandatory: {
          minWidth: 1280,
          minHeight: 720
        }
      }
    };

    var sdConstraints = {
      video: {
        mandatory: {
          minWidth: 480,
          minHeight: 360
        }
      }
    };

    var dataBuffer = -1;

    function grayscale(r,g,b) {
      //3*r+4*g+b) >>> 3
      return (0.21 * r + 0.72 * g + 0.07 * b);
    }

    function compareNumbers(a,b) {
      return a - b;
    }

    var Filter = {
      convolverActive: false,


      burnX: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r ^ (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g ^ (data[i - 20000] || 255);
          data[i+2] = b ^ (data[i * 2] || 255);
        }

        return data
      },

      burnO: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r | (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g | (data[i - 20000] || 255);
          data[i+2] = b | (data[i * 2] || 255);
        }

        return data
      },

      burnA: function(imageData) {
        var l = imageData.data.length,
            data = imageData.data,
            i = 0,
            r,g,b;

        var buffer = dataBuffer.data;

        for (i; i < l; i += 4) {
          r = data[i];
          g = data[i+1];
          b = data[i+2];


          data[i] =   r & (data[i / 2] || 255);//(data[i +100] || 255);
          data[i+1] = g & (data[i - 20000] || 255);
          data[i+2] = b & (data[i * 2] || 255);
        }

        return data
      },

      bayerColor: function(imageData) {
        var w = imageData.width;
        var data = imageData.data;
        var length = data.length;

        var i = 0;
        var bayerColor = {
          0: [0,0,0],
          1: [255,0,0],
          2: [0,255,0],
          3: [0,0,255],
          4: [255,255,0],
          5: [255,0,255],
          6: [0,255,255],
          7: [100,100,100],
          8: [255,255,255],
          9: [255,255,255]
        }

        while ((i = i + 12) < length) {
          var pixVal = (((8 * (data[i]+data[i+1]+data[i+2])) / 765) | 0) + 1;
          var newcolor = bayerColor[pixVal];
          
          data[i] = newcolor[0];
          data[i+1] = newcolor[1];
          data[i+2] = newcolor[2];
        }

        return data;
      }
    };


    function CanvasView(el, stream) {
      // Whether or not the view screen is receiving data.
      this.active = false;
      this.canvas = el;
      this.canvasContext = this.canvas.getContext('2d');
      this.stream = stream;
      this.backingVideo = document.createElement('video');


      this.height = this.canvas.height;
      this.width = this.canvas.width;

      this.canvas.width = this.width * 2;
      this.canvas.height = this.height * 2;

      this.canvas.style.width = this.width + 'px';
      this.canvas.style.height = this.height + 'px';

      this.initialize();
    }
    
    CanvasView.prototype.initialize = function() {
      document.getElementById("snapshot").addEventListener("click", this.takePhoto.bind(this));
      document.getElementById("canvasBlur").addEventListener("input", this.blur.bind(this));
      this.backingVideo.addEventListener('loadeddata', function() {
        
        this.backingVideo.play();
        this.trigger('ON_VIDEO_LOAD');

      }.bind(this));

      this.backingVideo.src = window.URL.createObjectURL(this.stream);
      this.active = true;
      
      VL.Events.prototype.attachTo(this);
      
      return this;
    };

    CanvasView.prototype.blur = function(event) {
      if (!this.isActive()) return false;


      var ctx = this.canvas.getContext("2d"),
          currentAlpha = ctx.globalAlpha;

      ctx.globalAlpha = +event.target.value;
    },

    CanvasView.prototype.getPixels = function() {
      if (!this.isActive()) {
        return null;
      }
      
      this.canvasContext.drawImage(this.backingVideo, 0, 0);
      var data = this.canvasContext.getImageData(0, 0, this.width*2, this.height*2);
     // this.canvasContext.transform(1,0.5,-0.5,1,10,10);
      return data;
    };

    CanvasView.prototype.draw = function(imageData) {
      if (!this.isActive()) {
        return false;
      }

      this.canvasContext.putImageData(imageData, 0, 0);
      
      return true;
    };

    CanvasView.prototype.isActive = function() {
      return this.active;
    };

    CanvasView.prototype.takePhoto = function(evt) {
      var anchor, click;

      anchor = document.createElement("a");
      anchor.href = this.canvas.toDataURL("image/png");
      
      
      anchor.download = "image"+ +new Date() + ".png";

      click = document.createEvent("Event");
      click.initEvent("click", true, true);

      anchor.dispatchEvent(click);
    };

    CanvasView.prototype.constructor = CanvasView;






    function FilterView(el) {
      this.el = el;

      this.activeFilters = collection;
      this.filters = [];

     
      var self = this;
      this.activeFilters.on('model.change.active', function(evt, newVal,oldVal,model) {
        if (newVal) {
          self.addFilter(model);
        } else {
          self.filters.splice(self.filters.indexOf(model),1);
        }
      });
    }


    FilterView.prototype.addFilter = function(filter) {
      this.filters.push(filter);
      
      return this.filters;
    };


    FilterView.prototype.process = function(imageData) {
      for (var i = 0; i < this.filters.length; i++) {
        var filter = this.filters[i];
        var type = filter.get('type');

        if (type === 'convolver') {
          imageData = filter.convolve(imageData, filter.get('matrix'));
        } else {
          imageData.data = this.filters[i].filter(imageData);  
        }
      }

      return imageData;
    };

    FilterView.prototype._buildConvolver = function(evt) {
      var convolver = evt.currentTarget.value;


      var filter;

      // Todo make these models.
      switch (convolver) {
        case "laplace":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [1,1,1,1,-8,1,1,1,1]
          };
          break;
        case "sharpen":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [0,-1,0,-1,5,-1,0,-1,0]
          };
          break;
        case "blur":
          var b = 1/9;
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [b,b,b,b,b,b,b,b,b]
          };
          break;
        case "edge":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [-6,-4,0,-10,10,1,0,4,6]
          }
          break;
        case "emboss":
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [-2,-1,0,-1,1,1,0,1,2]
          }
          break;
        case 'sobel':
          filter = {
            name: convolver,
            type: 'convolver',
            matrix: [-1,0,1,-2,0,2,-1,0,1]
          }
          break;
      }

      return filter;
    };

    FilterView.prototype.constructor = FilterView;





    function AppController() {
      // sub view representing the canvas element
      this.canvasView = null;
      // subview representing the filter nodes
      this.filtersView = new FilterView(document.querySelector('.filters'));

      this.allowedAccessToCamera = false;

      // Pointer to the id of the current animation frame
      this.rfid = null;

      this.initialize();
    };


    AppController.prototype.initialize = function() {
      Services.UserMedia.getStream(this.onAfterStreamRequest.bind(this));
    };

    AppController.prototype.onAfterStreamRequest = function(stream) {
      if (!stream) {
        return console.log('User denied access to their webcam.');
      }

      this.allowedAccessToCamera = true;  
      
      this.canvasView = new CanvasView(document.querySelector('canvas'), stream);
      this.canvasView.on('ON_VIDEO_LOAD', this.startAnimationLoop.bind(this));
    };

    AppController.prototype.startAnimationLoop = function() {
      var self = this;

      function animationCallback() {
        var transformedData = self.filtersView.process(self.canvasView.getPixels()); 
        var shouldKeepDrawing = self.canvasView.draw(transformedData);

        if (!shouldKeepDrawing) {
          window.cancelAnimationFrame(self.rfid);
          self.rfid = null;
          return;
        }

        self.rfid = window.requestAnimationFrame(animationCallback);
      }

      this.rfid = window.requestAnimationFrame(animationCallback);
    };


    // Take a snapshot with your browser
    function PhotoBooth() {
      // Do we have an active booth
      this.active = false;

      // The media stream object
      this.stream = null;

      // The booth itself
      this.canvas = document.querySelector("canvas");

      // The video element playing our camera feed.
      this.video = document.getElementById("camera-input");

      // The canvas context
      this.canvasCtx = null;

      // Has the user allowed camera access
      this.allowedAccessToCamera = false;

      // The aspect ratio
      this.aspectRatio = null;

      this.shouldStore = false;

      this.filters = [];

      this.height = this.canvas.height;
      this.width = this.canvas.width;

      this.canvas.width = this.width * 2;
      this.canvas.height = this.height * 2;

      this.canvas.style.width = this.width + 'px';
      this.canvas.style.height = this.height + 'px';


      this.canvas.getContext('2d').scale(2, 2);

      this.requestAccess();
      this.bindEvents();
    }

    PhotoBooth.prototype = {
      bindEvents: function() {
        document.getElementById("snapshot").addEventListener("click", this.takePhoto.bind(this));
        document.getElementById("canvasBlur").addEventListener("input", this.blur.bind(this));
        document.getElementById("stop").addEventListener("click", this.toggleVideo.bind(this));
        var nodes = document.querySelectorAll(".filter")

        for  (var i = 0; i < nodes.length; i++) {
          nodes[i].addEventListener("click", this.addFilter.bind(this));
        }

        var convolvers = document.querySelectorAll(".convolver");

        for  (var i = 0; i < convolvers.length; i++) {
          convolvers[i].addEventListener("click", this.convolve.bind(this));
        }

        document.getElementById("reset").addEventListener("click", this.reset.bind(this));
        document.getElementById("loop").addEventListener('click', this.store.bind(this))
      },

      store: function() {
        if (this.shouldStore) {
          dataBuffer.length = 0;
        }

        this.shouldStore = !this.shouldStore;
      },

      requestAccess: function() {
        Services.UserMedia.getStream(function(stream) {
          if (!stream) {
            return console.log('No webcam acccess');
          }
          
          new ViewScreen(document.querySelector('canvas'), stream);
          this.stream = stream;
          this.active = true;
          this.allowedAccessToCamera = true;

          this.video.src = window.URL.createObjectURL(this.stream);

          this.video.addEventListener('loadeddata', this._onVideoDataReady.bind(this));
        }.bind(this));
      },

      draw: function(time) {
        var i = 0;

        if (!this._isActive()) {
          return window.cancelAnimationFrame(this.rfid);
        }

        this.canvasCtx.drawImage(this.video, 0, 0);
        var output = imageData = this.canvasCtx.getImageData(0, 0, this.width*2, this.height*2);
        

        if (this.convolver) {
          imageData = output = Filter.convolve(imageData, this.convolver.matrix);
        }

        if (this.filters.length != 0) {
          while(i < this.filters.length) {
            output.data = Filter[this.filters[i]](output);
            i++;
          }

          this.canvasCtx.putImageData(output, 0, 0);
        } else {
          this.canvasCtx.putImageData(imageData, 0, 0);
        }
        var self = this;
        
        
          if (dataBuffer === -1) {
            dataBuffer = [];
          } else if (dataBuffer.length === 0) {
            dataBuffer = output;  
          }

        this.rfid =  window.requestAnimationFrame(self.draw.bind(self));
        
      },

      _onVideoDataReady: function(evt) {
        this.video.play();

        this.canvasCtx = this.canvas.getContext("2d");

        var output = imageData = null;

        this.rfid = window.requestAnimationFrame(this.draw.bind(this));
      },

      addFilter: function(evt) {
        if (!this.allowedAccessToCamera && !this._isActive) return false;

        var selectedFilter = evt.currentTarget.value;

        if (this.filters.indexOf(selectedFilter) !== -1) {
          this.filters.splice(this.filters.indexOf(selectedFilter), 1);

          return;
        }

        this.filters.push(selectedFilter);
      },

      convolve: function(evt) {
        var convolver = evt.currentTarget.innerHTML.toLowerCase();

        if (this.convolver && this.convolver.type === convolver) {
          return this.convolver = null;
        }

        switch (convolver) {
          case "laplace":
            this.convolver = {
              type: convolver,
              matrix: [1,1,1,1,-8,1,1,1,1]
            };
            break;
          case "sharpen":
            this.convolver = {
              type: convolver,
              matrix: [0,-1,0,-1,5,-1,0,-1,0]
            };
            break;
          case "blur":
            var b = 1/9;
            this.convolver = {
              type: convolver,
              matrix: [b,b,b,b,b,b,b,b,b]
            };
            break;
          case "edge":
            this.convolver = {
              type: convolver,
              matrix: [-6,-4,0,-10,10,1,0,4,6]
            }
            break;
          case "emboss":
            this.convolver = {
              type: convolver,
              matrix: [-2,-1,0,-1,1,1,0,1,2]
            }
            break;
          case 'sobel':
            this.convolver = {
              type: convolver,
              matrix: [-1,0,1,-2,0,2,-1,0,1]
            }
            break;
        }
      },

      _isActive: function() {
        return this.active && this.stream;
      },

      blur: function(event) {
        if (!this._isActive()) return false;


        var ctx = this.canvas.getContext("2d"),
            currentAlpha = ctx.globalAlpha;

        ctx.globalAlpha = +event.target.value;
      },

      toggleVideo: function() {
        if (this._isActive()) {
          this.video.pause();
          this.active = false;
        } else {
          this.video.play();
          this.active = true;
          this.draw();
        }
      },

      takePhoto: function(evt) {
        //if (!this._isActive()) return false;

        var anchor, click;

        anchor = document.createElement("a");
        anchor.href = this.canvas.toDataURL("image/png");
        //window.location = this.canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
        //return;
        anchor.download = "image"+ +new Date() + ".png";

//anchor.innerHTML = 'p';
  //  document.body.appendChild(anchor);
  //  return;
        click = document.createEvent("Event");
        click.initEvent("click", true, true);

        anchor.dispatchEvent(click);
      },

      reset: function() {
        this.filters.length = 0;
      }
    };

    if (Services.Browser.isChrome()) {
      //new PhotoBooth();
      new AppController();
    } else {
      alert("This page only supports Google Chrome, version 29 or higher.");
    }
  </script>
</body>
</html>
