<!DOCTYPE html>
<html>
<head>
  <title>WebRTC codelab</title>
  <style>
    video {
      display:none;
    }
    canvas {
      background: transparent;
    }
  </style>

  <script type="text/template" id="variable-filter">
    <form oninput="level.value = {{=it.name}}.valueAsNumber;">
      <input class="filter" type="checkbox" name="filter"/>{{=it.name}}
      <input type="range" min="{{=it.min}}" max="{{=it.max}}" id="{{=it.name}}-filter" name="{{=it.name}}" value="{{=it.currentValue}}" step="{{=it.step}}" class="variable-filter"/>
      <output style="margin-left: 20px; padding:14px;" for="{{=it.name}}-filter" name="level">{{=it.currentValue}}</output>
    </form>
  </script>

  <script type="text/template" id="fixed-filter">
    <input class="filter" type="checkbox" name="filter" value="{{=it.name}}">{{=it.name}}<br>
  </script>

  <script type="text/template" id="convolver">
    <button class="convolver {{=it.active}}" value='{{=it.name}}'>{{=it.name}}</button></br>
  </script>
  
  <!-- OPTICAL FLOW LIBRARY -->
  <script src="js/lib/oflow/flow-zone.js"></script>
  <script src="js/lib/oflow/flow-calculator.js"></script>
  <script src="js/lib/oflow/colors.js"></script>
  <script src="js/lib/oflow/video-flow.js"></script>
  <script src="js/lib/oflow/webcam-flow.js"></script>
  

  <script src='js/dot.js'></script>
  <script src="js/util.js"></script>
  <script src="js/services.js"></script>
  <script src="js/framework.js"></script>

  <script src="js/models/convolver.js"></script>
  <script src="js/models/grayscale-filter.js"></script>
  <script src="js/models/contrast-filter.js"></script>
  <script src="js/models/brightness-filter.js"></script>
  <script src="js/models/saturation-filter.js"></script>
  <script src="js/models/inversion-filter.js"></script>
  <script src="js/models/sepia-filter.js"></script>
  <script src="js/models/emboss-filter.js"></script>
  <script src="js/models/threshold-filter.js"></script>
  <script src="js/models/bayer-filter.js"></script>
  <script src="js/models/low-res.js"></script>
  <script src="js/models/xor-filter.js"></script>
  <script src="js/models/and-filter.js"></script>
  <script src="js/models/median-filter.js"></script>
  <script src="js/models/sobel-filter.js"></script>
  <script src="js/models/laplace.js"></script>
  <script src="js/models/sharpen.js"></script>
  <script src="js/models/blur.js"></script>
  <script src="js/models/emboss.js"></script>

  
  <script src="js/collections/filter-collection.js"></script>


  <script src="js/views/filter-view.js"></script>
  <script src="js/views/variable-filter.js"></script>
  <script src="js/views/convolution-view.js"></script>
  <script src="js/views/filter-collection-view.js"></script>
</head>
<body>
  <video id="camera-input"></video>
  <canvas width="640" height="360"></canvas>
  <br>
  <div style='float:right; margin-right:200px;'>
    <div id='cc'></div>
  </div>
  <div>
    <button id="snapshot">Take a Photo</button>
    <form name='canvas-blur' oninput="level.value = canvasBlur.valueAsNumber;">
      <label for="canvasBlur">Blur</label>
      <input type="range" min="0.0" max="1.0" step="0.1" id="canvasBlur" name="canvasBlur" value="1.0"/>
      <output for="canvasBlur" name="level">1.0</output>
    </form>

    <button id="stop">Stop</button>
    <button id="feedback">Feedback</button>
    <button id="reset">Reset</button>

    <button id='loop'>Store last second of video</button>


    <div class='filters'>
      <br><br>
      <div style="float: left; margin-left: 20px; margin-right: 20px;">
        <h4>Fixed Filters</h4>
        <div id='grayscale'></div>
        <div id='invert'></div>
        <div id='sepia'></div>
        <div id='emboss'></div>
        <div id='low-res'></div>
        <div id='bayer'></div>
        <div id='xor'></div>
        <div id='and'></div>
      </div>

      <div style="float: left; margin-left: 20px; margin-right: 20px;">
        <h4>Variable Filters</h4>

        <div id='contrast'></div>
        <div id='brightness'></div>
        <div id='saturation'></div>
        <div id='threshold'></div>
        <div id='median'></div>
      </div>

      <div style="float: left; margin-left: 20px; margin-right: 20px;">
        <h4>Convolvers</h4>

        <div id='sobel'></div>
        <div id='laplace'></div>
        <div id='sharpen'></div>
        <div id='blur'></div>
        <div id='embossC'></div>
      </div>
    </div>
  
    
    <div id="image-data">
      <img src='' id="image-preview" height="150" width="150"/>
      <input type="file" id="file-upload" accept="image/gif, image/jpeg, image/png"/>
    </div>

  </div>

  <script>
    var currentFile = null;
    var reader = new FileReader();
    var imageCanvas = document.createElement('canvas');
    var imgEl = document.getElementById('image-preview');
    var currentFileData = null;

    reader.onload = function(event) {
      var img = new Image();

      img.onload = function() {
        imageCanvas.width = img.width * 2;
        imageCanvas.height = img.height * 2;
        var context = imageCanvas.getContext('2d');

        context.drawImage(img, 0, 0);

        currentFileData = context.getImageData(0,0,this.width *2 , this.height *2).data;
        
        imgEl.src = this.src;
      };

      img.src = event.target.result;
    };

    document.getElementById('file-upload').addEventListener('change', function(event) {
      var file = event.currentTarget.files[0];

      if (file) {
        currentFile = file;
        reader.readAsDataURL(file);
      }
    });

   
    
    var gsf = new GrayscaleFilter();
    var bf = new BrightnessFilter();
    var cf = new ContrastFilter();
    var sf = new SaturationFilter();
    var ivf = new InversionFilter();
    var spf = new SepiaFilter();
    var ef = new EmbossFilter();
    var tf = new ThresholdFilter();
    var byf = new BayerFilter();
    var lrf = new LowResFilter();
    var xof = new XORFilter();
    var and = new AndFilter();
    var mdf = new MedianFilter();
    var sbf = new SobelFilter();
    var lpf = new LaplaceFilter();
    var shf = new SharpenFilter();
    var blf = new BlurFilter();
    var ebc = new EmbossConvolver();

    var filterCollection = new FilterCollection({
      models: [gsf, cf, bf, sf, ivf, spf, ef, tf, byf, lrf, xof, mdf, sbf, lpf,shf,blf,ebc, and]
    });

    // Fixed Filters
    new FixedFilterView({el: '#grayscale', model: gsf}).render();
    new FixedFilterView({el: '#sepia', model: spf}).render();
    new FixedFilterView({el: '#invert', model: ivf}).render();
    new FixedFilterView({el: '#emboss', model: ef}).render();
    new FixedFilterView({el: '#low-res', model: lrf}).render();
    new FixedFilterView({el: '#bayer', model: byf}).render();
    new FixedFilterView({el: '#xor', model: xof}).render(); 
    new FixedFilterView({el: '#and', model: and}).render(); 

    new VariableFilterView({el: '#saturation', model: sf}).render();
    new VariableFilterView({el: '#contrast', model: cf}).render();
    new VariableFilterView({el: '#brightness', model: bf}).render();
    new VariableFilterView({el: '#threshold', model: tf}).render();
    new VariableFilterView({el: '#median', model: mdf}).render();

    new ConvolutionFilterView({el: '#sobel', model: sbf}).render();
    new ConvolutionFilterView({el: '#laplace', model: lpf}).render();
    new ConvolutionFilterView({el: '#sharpen', model: shf}).render();
    new ConvolutionFilterView({el: '#blur', model: blf}).render();
    new ConvolutionFilterView({el: '#embossC', model: ebc}).render();
   

    var hdConstraints = {
      video: {
        mandatory: {
          minWidth: 1280,
          minHeight: 720
        }
      }
    };

    var sdConstraints = {
      video: {
        mandatory: {
          minWidth: 480,
          minHeight: 360
        }
      }
    };

    var Filter = {
      bayerColor: function(imageData) {
        var w = imageData.width;
        var data = imageData.data;
        var length = data.length;

        var i = 0;
        var bayerColor = {
          0: [0,0,0],
          1: [255,0,0],
          2: [0,255,0],
          3: [0,0,255],
          4: [255,255,0],
          5: [255,0,255],
          6: [0,255,255],
          7: [100,100,100],
          8: [255,255,255],
          9: [255,255,255]
        }

        while ((i = i + 12) < length) {
          var pixVal = (((8 * (data[i]+data[i+1]+data[i+2])) / 765) | 0) + 1;
          var newcolor = bayerColor[pixVal];
          
          data[i] = newcolor[0];
          data[i+1] = newcolor[1];
          data[i+2] = newcolor[2];
        }

        return data;
      }
    };

    function CanvasView(el, stream) {
      // Whether or not the view screen is receiving data.
      this.active = false;
      this.feedback = !!this.feedback;
      this.canvas = el;
      this.canvasContext = this.canvas.getContext('2d');
      this.stream = stream;
      this.backingVideo = document.createElement('video');

      this.height = this.canvas.height;
      this.width = this.canvas.width;
//
     // this.canvas.width = this.width * 2;
      //this.canvas.height = this.height * 2;

      // this.canvas.style.width = this.canvas.width + 'px';
      // this.canvas.style.height = this.canvas.height + 'px';

      this.initialize();
    }
    
    CanvasView.prototype.initialize = function() {
      document.getElementById("snapshot").addEventListener("click", this.takePhoto.bind(this));
      document.getElementById("feedback").addEventListener("click", this.toggleFeedback.bind(this));
      document.getElementById("canvasBlur").addEventListener("input", this.blur.bind(this));
      this.backingVideo.addEventListener('loadeddata', function() {
        
        this.backingVideo.play();
        this.trigger('ON_VIDEO_LOAD');

      }.bind(this));

      this.backingVideo.src = window.URL.createObjectURL(this.stream);
      this.active = true;
      
      VL.Events.prototype.attachTo(this);
      
      return this;
    };

    CanvasView.prototype.blur = function(event) {
      if (!this.isActive()) {
        return false;
      }


      var ctx = this.canvas.getContext("2d"),
          currentAlpha = ctx.globalAlpha;

      ctx.globalAlpha = +event.target.value;
    };

    CanvasView.prototype.toggleFeedback = function() {
      if (!this.isActive()) {
        return false;
      }

      this.feedback = !this.feedback;
    };

    CanvasView.prototype.getPixels = function() {
      if (!this.isActive()) {
        return null;
      }
      
      if (!this.feedback) {
        this.canvasContext.drawImage(this.backingVideo, 0, 0);
      }

      var data = this.canvasContext.getImageData(0, 0, this.width, this.height);

      return data;
    };

    CanvasView.prototype.draw = function(imageData) {
      if (!this.isActive()) {
        return false;
      }

      // var newImage = imageData.data;
      
      // if (oldImage && newImage) {
      //   var zones = calculator.calculate(oldImage, newImage, this.width, this.height);
      //   calculatedCallbacks.forEach(function (callback) {
      //     callback(zones);
      //   });
      // } 
      
      // oldImage = newImage;

      this.canvasContext.putImageData(imageData, 0, 0);
      
      return true;
    };

    CanvasView.prototype.drawFlow = function(direction) {
      var ctx = this.canvasContext;
      ctx.clearRect(0, 0, this.width, this.height);
      
      for(var i = 0; i < direction.zones.length; ++i) {
        var zone = direction.zones[i];
        
      
      var distance = Math.pow(zone.x - (zone.x - zone.u),2) + Math.pow(zone.y - (zone.y + zone.v),2);
      
        if (distance < 20) {
          continue;
        }

        ctx.strokeStyle = getDirectionalColor(zone.u, zone.v);
        ctx.beginPath();
        ctx.moveTo(zone.x,zone.y);
       
        ctx.lineTo((zone.x - zone.u), zone.y + zone.v);
       
        ctx.lineWidth = 5;
        ctx.stroke();
      }

      return true;
    };

    CanvasView.prototype.isActive = function() {
      return this.active;
    };

    CanvasView.prototype.takePhoto = function(evt) {
      var anchor, click;

      anchor = document.createElement("a");
      anchor.href = this.canvas.toDataURL("image/png");
      
      
      anchor.download = "image"+ +new Date() + ".png";

      click = document.createEvent("Event");
      click.initEvent("click", true, true);

      anchor.dispatchEvent(click);
    };

    CanvasView.prototype.constructor = CanvasView;

    
    // function FlowController() {
    //   this.webcamFlow = 
    // }

    // FlowController.prototype.constructor = FlowController;


    function AppController() {
      // sub view representing the canvas element
      this.canvasView = null;
      // subview representing the filter nodes
      this.filtersView = new FilterCollectionView({
        el: '.filters',
        collection: filterCollection
      });

      this.webCamFlow = new OFlow.WebCamFlow(new OFlow.VideoFlow(20));
      
      this.webCamFlow.onCalculated(function(direction) {
        this.canvasView.drawFlow(direction);
      }.bind(this));

      this.allowedAccessToCamera = false;

      // Pointer to the current animation frame handler
      this.rfid = null;

      this.initialize();
    };


    AppController.prototype.initialize = function() {
      Services.UserMedia.getVideoStream(this.onAfterStreamRequest.bind(this));
    };

    AppController.prototype.onAfterStreamRequest = function(stream) {
      if (!stream) {
        return console.log('User denied access to their webcam.');
      }

      this.allowedAccessToCamera = true;  
      
      this.canvasView = new CanvasView(document.querySelector('canvas'), stream);
      this.canvasView.on('ON_VIDEO_LOAD', this.startAnimationLoop.bind(this));
    };

    AppController.prototype.startAnimationLoop = function() {
      var self = this;

      function animationCallback() {
        var transformedData = self.filtersView.process(self.canvasView.getPixels()); 
        
        
          var shouldKeepDrawing = self.canvasView.draw(transformedData);
        
        
        
        self.webCamFlow.calculate(transformedData.data, self.canvasView.width, self.canvasView.height);
        
        
        // var shouldKeepDrawing = true;
        // if (!shouldKeepDrawing) {
        //   window.cancelAnimationFrame(self.rfid);
        //   self.rfid = null;
        //   return;
        // }

        // self.rfid = window.requestAnimationFrame(animationCallback);
      }
      
      setInterval(animationCallback, 100);
     // this.rfid = window.requestAnimationFrame(animationCallback);
    };

    if (Services.Browser.isChrome()) {
      //new PhotoBooth();
      new AppController();
    } else {
      alert("This page only supports Google Chrome, version 29 or higher.");
    }
  </script>
</body>
</html>
